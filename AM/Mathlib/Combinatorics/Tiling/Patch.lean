/-
Copyright (c) 2024 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers
-/
import AM.Mathlib.Combinatorics.Tiling.Function.Disjoint
import AM.Mathlib.Combinatorics.Tiling.TileSetCard

/-!
# Patches in tilings

This file defines patches in tilings in a discrete context.

The patch generated by a set of points consists of all tiles containing any of those points. In a
continuous, planar context, the definition commonly includes adding any further tiles needed to
fill up any holes so that the patch is a topological disk (see Grünbaum and Shephard, for
example); this does not make sense in more general contexts so is not included in the definitions
here.

## Main definitions

* `t.subtype p`: The `TileSet` of those tiles from `t` whose indices have property `p`.
* `t.patch s`: The `TileSet` of those tiles from `t` containing a point from `s`.

## References

* [Branko Grünbaum and G. C. Shephard, *Tilings and Patterns*][GrunbaumShephard1987]
-/


noncomputable section

namespace Discrete

open Function
open scoped Cardinal Pointwise

variable {G X ιₚ ιₜ ιₜ' Eᵤ : Type*} [Group G] [MulAction G X] {ps : Protoset G X ιₚ}
universe u
variable {ιᵤ ιᵤ' : Type u} [EquivLike Eᵤ ιᵤ' ιᵤ]

namespace TileSet

/-- The `TileSet` of those tiles from `t` whose indices have property `p`. -/
protected def subtype (t : TileSet ps ιₜ) (p : ιₜ → Prop) : TileSet ps (Subtype p) :=
  t.reindex Subtype.val

@[simp] lemma coe_subtype (t : TileSet ps ιₜ) (p : ιₜ → Prop) : ↑(t.subtype p) = ↑t ∘ Subtype.val :=
  rfl

@[simp] lemma subtype_apply (t : TileSet ps ιₜ) (p : ιₜ → Prop) (i : Subtype p) :
    t.subtype p i = t i :=
  rfl

lemma injective_subtype_of_injective {t : TileSet ps ιₜ} (p : ιₜ → Prop) (ht : Injective t) :
    Injective (t.subtype p) :=
  (injective_reindex_iff_injective ht).2 Subtype.val_injective

lemma reindex_subtypeEquiv (t : TileSet ps ιₜ) {p : ιₜ → Prop} {e : ιₜ' ≃ ιₜ} {q : ιₜ' → Prop}
    (h : ∀ i, q i ↔ p (e i)) :
    (t.subtype p).reindex (Equiv.subtypeEquiv e h) = (t.reindex e).subtype q :=
  rfl

lemma reindex_subtypeEquivRight (t : TileSet ps ιₜ) {p q : ιₜ → Prop} (h : ∀ i, q i ↔ p i) :
    (t.subtype p).reindex (Equiv.subtypeEquivRight h) = t.subtype q :=
  rfl

lemma coeSet_subtype (t : TileSet ps ιₜ) (p : ιₜ → Prop) : t.subtype p = t '' {i | p i} := by
  rw [TileSet.subtype, coeSet_reindex_eq_range_comp, Set.range_comp, Subtype.range_coe_subtype]

lemma coeSet_subtype_subset (t : TileSet ps ιₜ) (p : ιₜ → Prop) :
    (t.subtype p : Set (PlacedTile ps)) ⊆ t :=
  t.coeSet_reindex_subset _

lemma mem_subtype_iff {t : TileSet ps ιₜ} {p : ιₜ → Prop} {pt : PlacedTile ps} :
    pt ∈ t.subtype p ↔ ∃ i, p i ∧ t i = pt := by
  rw [← mem_coeSet, coeSet_subtype]
  simp

lemma mem_of_mem_subtype {t : TileSet ps ιₜ} {p : ιₜ → Prop} {pt : PlacedTile ps}
    (h : pt ∈ t.subtype p) : pt ∈ t :=
  t.mem_of_mem_reindex h

lemma smul_subtype (g : G) (t : TileSet ps ιₜ) (p : ιₜ → Prop) :
    g • (t.subtype p) = (g • t).subtype p :=
  t.smul_reindex _ _

lemma card_subtype_le (t : TileSet ps ιₜ) (p : ιₜ → Prop) : (t.subtype p).card ≤ t.card :=
  t.card_reindex_le_of_injective Subtype.val_injective

protected lemma Disjoint.subtype {t : TileSet ps ιₜ} (hd : t.Disjoint) (p : ιₜ → Prop) :
    (t.subtype p).Disjoint :=
  TileSet.Disjoint.reindex_of_injective hd Subtype.val_injective

protected lemma FiniteIntersections.subtype {t : TileSet ps ιₜ}
    (hfi : t.FiniteIntersections) (p : ιₜ → Prop) :
    (t.subtype p).FiniteIntersections :=
  FiniteIntersections.reindex_of_injective hfi Subtype.val_injective

protected lemma FiniteDistinctIntersections.subtype {t : TileSet ps ιₜ}
    (hfi : t.FiniteDistinctIntersections) (p : ιₜ → Prop) :
    (t.subtype p).FiniteDistinctIntersections :=
  FiniteDistinctIntersections.reindex hfi

lemma union_subtype (t : TileSet ps ιₜ) (p : ιₜ → Prop) :
    ⋃ i, (t.subtype p i : Set X) = ⋃ (i) (_ : p i), (t i : Set X) := by
  ext x
  simp

lemma union_subtype' (t : TileSet ps ιₜ) (p : ιₜ → Prop) :
    ⋃ pt ∈ t.subtype p, (pt : Set X) = ⋃ (i) (_ : p i), (t i : Set X) := by
  rw [union_of_mem_eq_iUnion, union_subtype]

lemma reindex_subtypeSubtypeEquivSubtypeInter (t : TileSet ps ιₜ) (p q : ιₜ → Prop) :
    (t.subtype (fun i ↦ p i ∧ q i)).reindex (Equiv.subtypeSubtypeEquivSubtypeInter p q) =
      (t.subtype p).subtype (q ∘ Subtype.val) :=
  rfl

/-- The `TileSet` of those tiles from `t` containing a point from `s`. -/
def patch (t : TileSet ps ιₜ) (s : Set X) :
    TileSet ps (Subtype (fun i ↦ (s ∩ t i).Nonempty)) :=
  t.subtype _

@[simp] lemma coe_patch (t : TileSet ps ιₜ) (s : Set X) : ↑(t.patch s) = ↑t ∘ Subtype.val :=
  t.coe_subtype _

@[simp] lemma patch_apply (t : TileSet ps ιₜ) (s : Set X) (i) :
    t.patch s i = t i :=
  t.subtype_apply _ _

lemma card_patch_apply_of_inter_nonempty (t : TileSet ps ιₜ) {s : Set X} {pt : PlacedTile ps}
    (h : (s ∩ pt).Nonempty) : (t.patch s).card pt = #(↑t ⁻¹' {pt}) := by
  rw [card_apply, Cardinal.eq]
  let f : (t.patch s) ⁻¹' {pt} → t ⁻¹' {pt} := fun ⟨⟨i, _⟩, hi'⟩ ↦ ⟨i, hi'⟩
  refine ⟨Equiv.ofBijective f ⟨fun i j h ↦ ?_, fun i ↦ ⟨⟨⟨i, ?_⟩, ?_⟩, rfl⟩⟩⟩
  · simpa [coe_patch, Subtype.ext_iff, f] using h
  · convert h
    exact i.property
  · exact i.property

lemma card_patch_apply_of_inter_eq_empty (t : TileSet ps ιₜ) {s : Set X} {pt : PlacedTile ps}
    (h : (s ∩ pt) = ∅) : (t.patch s).card pt = 0 := by
  rw [card_apply, Cardinal.mk_eq_zero_iff]
  simp only [coe_patch, isEmpty_subtype, Set.mem_preimage, comp_apply, Set.mem_singleton_iff,
             Subtype.forall]
  rintro i hne rfl
  simp [h] at hne

lemma injective_patch_of_injective {t : TileSet ps ιₜ} (s : Set X) (ht : Injective t) :
    Injective (t.patch s) :=
  injective_subtype_of_injective _ ht

lemma patch_reindex_subtypeEquiv (t : TileSet ps ιₜ) (s : Set X) (e : ιₜ' ≃ ιₜ) :
    (t.patch s).reindex (Equiv.subtypeEquiv e fun _ ↦ Iff.rfl) = (t.reindex e).patch s :=
  rfl

lemma patch_reindex_subtypeEquivRight (t : TileSet ps ιₜ) {s₁ s₂ : Set X}
    (h : ∀ i, (s₂ ∩ t i).Nonempty ↔ (s₁ ∩ t i).Nonempty) :
    (t.patch s₁).reindex (Equiv.subtypeEquivRight h) = t.patch s₂ :=
  t.reindex_subtypeEquivRight h

@[simp] lemma card_patch_reindex_of_equivLike (t : TileSet ps ιᵤ) (s : Set X) (e : Eᵤ) :
    ((t.reindex e).patch s).card = (t.patch s).card := by
  change ((t.reindex (e : ιᵤ' ≃ ιᵤ)).patch s).card = _
  rw [← patch_reindex_subtypeEquiv]
  exact card_reindex_of_equivLike _ _

lemma coeSet_patch (t : TileSet ps ιₜ) (s : Set X) :
    t.patch s = t '' {i | (s ∩ t i).Nonempty} :=
  t.coeSet_subtype _

lemma coeSet_patch_subset (t : TileSet ps ιₜ) (s : Set X) :
    (t.patch s : Set (PlacedTile ps)) ⊆ t :=
  t.coeSet_subtype_subset _

lemma mem_of_mem_patch {t : TileSet ps ιₜ} {s : Set X} {pt : PlacedTile ps} (h : pt ∈ t.patch s) :
    pt ∈ t :=
  t.mem_of_mem_subtype h

lemma mem_patch_iff {t : TileSet ps ιₜ} {s : Set X} {pt : PlacedTile ps} :
    pt ∈ t.patch s ↔ (s ∩ pt).Nonempty ∧ pt ∈ t := by
  rw [patch, mem_subtype_iff, TileSet.mem_def, ←exists_and_left]
  refine exists_congr fun i ↦ ?_
  rw [and_congr_left_iff]
  rintro rfl
  rfl

/-- An equivalence between index subtypes for a patch from a `TileSet` and a corresponding patch
with the same group element applied to both the `TileSet` and the set of points. -/
def smulPatchEquiv (g : G) (t : TileSet ps ιₜ) (s : Set X) :
    {i // (g • s ∩ ((g • t) i)).Nonempty} ≃ {i // (s ∩ t i).Nonempty} :=
  Equiv.subtypeEquivRight (by simp)

lemma smul_patch (g : G) (t : TileSet ps ιₜ) (s : Set X) :
    (g • (t.patch s)).reindex (smulPatchEquiv g t s) = (g • t).patch (g • s) :=
  rfl

@[simp] lemma card_smul_patch (g : G) (t : TileSet ps ιₜ) (s : Set X) :
    ((g • t).patch (g • s)).card = g • (t.patch s).card := by
  rw [← smul_patch, ← card_smul, card_reindex_of_equivLike]

lemma card_patch_le (t : TileSet ps ιₜ) (s : Set X) : (t.patch s).card ≤ t.card :=
  t.card_subtype_le _

lemma Disjoint.patch {t : TileSet ps ιₜ} (hd : TileSet.Disjoint t) (s : Set X) :
    TileSet.Disjoint (t.patch s) :=
  TileSet.Disjoint.subtype hd _

protected lemma FiniteIntersections.patch {t : TileSet ps ιₜ}
    (hfi : t.FiniteIntersections) (s : Set X) :
    (t.patch s).FiniteIntersections :=
  FiniteIntersections.subtype hfi _

protected lemma FiniteDistinctIntersections.patch {t : TileSet ps ιₜ}
    (hfi : t.FiniteDistinctIntersections) (s : Set X) :
    (t.patch s).FiniteDistinctIntersections :=
  FiniteDistinctIntersections.subtype hfi _

lemma union_patch (t : TileSet ps ιₜ) (s : Set X) :
    ⋃ i, (t.patch s i : Set X) = ⋃ (i) (_ : (s ∩ t i).Nonempty), (t i : Set X) :=
  t.union_subtype _

lemma union_patch' (t : TileSet ps ιₜ) (s : Set X) :
    ⋃ pt ∈ t.patch s, (pt : Set X) = ⋃ (i) (_ : (s ∩ t i).Nonempty), (t i : Set X) :=
  t.union_subtype' _

/-- An equivalence between index subtypes for a patch of a patch and a corresponding patch taken
directly from the original `TileSet`. -/
def patchPatchEquiv (t : TileSet ps ιₜ) {s₁ s₂ : Set X} (h : s₂ ⊆ s₁) :
    {i // (s₂ ∩ t.patch s₁ i).Nonempty} ≃ {i // (s₂ ∩ t i).Nonempty} where
  toFun i := ⟨↑↑i, by exact i.property⟩
  invFun i := ⟨⟨↑i, i.property.mono <| by gcongr⟩, i.property⟩
  left_inv := by simp [LeftInverse]
  right_inv := by simp [Function.RightInverse, LeftInverse]

lemma patch_patch_reindex (t : TileSet ps ιₜ) {s₁ s₂ : Set X} (h : s₂ ⊆ s₁) :
    (t.patch s₂).reindex (t.patchPatchEquiv h) = (t.patch s₁).patch s₂ :=
  rfl

lemma card_patch_le_of_subset (t : TileSet ps ιₜ) {s₁ s₂ : Set X} (h : s₂ ⊆ s₁) :
    (t.patch s₂).card ≤ (t.patch s₁).card := by
  rw [← card_reindex_of_equivLike _ (t.patchPatchEquiv h), t.patch_patch_reindex h]
  exact card_patch_le _ _

lemma card_patch_union (t : TileSet ps ιₜ) (s₁ s₂ : Set X) :
    (t.patch (s₁ ∪ s₂)).card = (t.patch s₁).card ⊔ (t.patch s₂).card := by
  ext pt
  rw [TileSetCard.coe_sup, Pi.sup_apply]
  rcases Set.eq_empty_or_nonempty (s₁ ∩ pt) with h₁ | h₁
  · rw [t.card_patch_apply_of_inter_eq_empty h₁]
    rcases Set.eq_empty_or_nonempty (s₂ ∩ pt) with h₂ | h₂
    · rw [t.card_patch_apply_of_inter_eq_empty h₂]
      have h₁₂ : (s₁ ∪ s₂) ∩ pt = ∅ := by simp [Set.union_inter_distrib_right, h₁, h₂]
      simp [t.card_patch_apply_of_inter_eq_empty h₁₂]
    · rw [t.card_patch_apply_of_inter_nonempty h₂]
      have h₁₂ : ((s₁ ∪ s₂) ∩ pt).Nonempty :=
        h₂.mono (Set.inter_subset_inter_left _ Set.subset_union_right)
      simp [t.card_patch_apply_of_inter_nonempty h₁₂]
  · rw [t.card_patch_apply_of_inter_nonempty h₁]
    rcases Set.eq_empty_or_nonempty (s₂ ∩ pt) with h₂ | h₂
    · rw [t.card_patch_apply_of_inter_eq_empty h₂]
      have h₁₂ : ((s₁ ∪ s₂) ∩ pt).Nonempty :=
        h₁.mono (Set.inter_subset_inter_left _ Set.subset_union_left)
      simp [t.card_patch_apply_of_inter_nonempty h₁₂]
    · rw [t.card_patch_apply_of_inter_nonempty h₂]
      have h₁₂ : ((s₁ ∪ s₂) ∩ pt).Nonempty :=
        h₁.mono (Set.inter_subset_inter_left _ Set.subset_union_left)
      simp [t.card_patch_apply_of_inter_nonempty h₁₂]

end TileSet

end Discrete
