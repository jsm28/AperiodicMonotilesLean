/-
Copyright (c) 2024 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers
-/
import AM.Mathlib.Combinatorics.Tiling.Basic

/-!
# Patches in tilings

This file defines patches in tilings in a discrete context.

The patch generated by a set of points consists of all tiles containing any of those points. In a
continuous, planar context, the definition commonly includes adding any further tiles needed to
fill up any holes so that the patch is a topological disk (see Grünbaum and Shephard, for
example); this does not make sense in more general contexts so is not included in the definitions
here.

## Main definitions

* `TileSet.subtype t p`: The `TileSet` of those tiles from `t` whose indices have property `p`.
* `TileSet.patch t s`: The `TileSet` of those tiles from `t` containing a point from `s`.

## References

* Branko Grünbaum and G. C. Shephard, Tilings and Patterns, 1987
-/


noncomputable section

namespace Discrete

open Function
open scoped Pointwise

variable {G X ιₚ ιₜ ιₜ' : Type*} [Group G] [MulAction G X] {ps : Protoset G X ιₚ}

namespace TileSet

/-- The `TileSet` of those tiles from `t` whose indices have property `p`. -/
protected def subtype (t : TileSet ps ιₜ) (p : ιₜ → Prop) : TileSet ps (Subtype p) :=
  t.reindex Subtype.val

@[simp] lemma coe_subtype (t : TileSet ps ιₜ) (p : ιₜ → Prop) : ↑(t.subtype p) = ↑t ∘ Subtype.val :=
  rfl

@[simp] lemma subtype_apply (t : TileSet ps ιₜ) (p : ιₜ → Prop) (i : Subtype p) :
    t.subtype p i = t i :=
  rfl

lemma injective_subtype_of_injective {t : TileSet ps ιₜ} (p : ιₜ → Prop) (ht : Injective t) :
    Injective (t.subtype p) :=
  (injective_reindex_iff_injective ht).2 Subtype.val_injective

lemma reindex_subtypeEquiv (t : TileSet ps ιₜ) {p : ιₜ → Prop} {e : ιₜ' ≃ ιₜ} {q : ιₜ' → Prop}
    (h : ∀ i, q i ↔ p (e i)) :
    (t.subtype p).reindex (Equiv.subtypeEquiv e h) = (t.reindex e).subtype q :=
  rfl

lemma reindex_subtypeEquivRight (t : TileSet ps ιₜ) {p q : ιₜ → Prop} (h : ∀ i, q i ↔ p i) :
    (t.subtype p).reindex (Equiv.subtypeEquivRight h) = t.subtype q :=
  rfl

lemma coeSet_subtype (t : TileSet ps ιₜ) (p : ιₜ → Prop) : t.subtype p = t '' {i | p i} := by
  rw [TileSet.subtype, coeSet_reindex_eq_range_comp, Set.range_comp, Subtype.range_coe_subtype]

lemma coeSet_subtype_subset (t : TileSet ps ιₜ) (p : ιₜ → Prop) :
    (t.subtype p : Set (PlacedTile ps)) ⊆ t :=
  t.coeSet_reindex_subset _

lemma mem_subtype_iff {t : TileSet ps ιₜ} {p : ιₜ → Prop} {pt : PlacedTile ps} :
    pt ∈ t.subtype p ↔ ∃ i, p i ∧ t i = pt := by
  rw [← mem_coeSet, coeSet_subtype]
  simp

lemma mem_of_mem_subtype {t : TileSet ps ιₜ} {p : ιₜ → Prop} {pt : PlacedTile ps}
    (h : pt ∈ t.subtype p) : pt ∈ t :=
  t.mem_of_mem_reindex h

lemma smul_subtype (g : G) (t : TileSet ps ιₜ) (p : ιₜ → Prop) :
    g • (t.subtype p) = (g • t).subtype p :=
  t.smul_reindex _ _

protected lemma Disjoint.subtype {t : TileSet ps ιₜ} (hd : TileSet.Disjoint t) (p : ιₜ → Prop) :
    TileSet.Disjoint (t.subtype p) :=
  TileSet.Disjoint.reindex_of_injective hd Subtype.val_injective

lemma union_subtype (t : TileSet ps ιₜ) (p : ιₜ → Prop) :
    ⋃ i, (t.subtype p i : Set X) = ⋃ (i) (_ : p i), (t i : Set X) := by
  ext x
  simp

lemma union_subtype' (t : TileSet ps ιₜ) (p : ιₜ → Prop) :
    ⋃ pt ∈ t.subtype p, (pt : Set X) = ⋃ (i) (_ : p i), (t i : Set X) := by
  rw [union_of_mem_eq_iUnion, union_subtype]

lemma reindex_subtypeSubtypeEquivSubtypeInter (t : TileSet ps ιₜ) (p q : ιₜ → Prop) :
    (t.subtype (fun i ↦ p i ∧ q i)).reindex (Equiv.subtypeSubtypeEquivSubtypeInter p q) =
      (t.subtype p).subtype (q ∘ Subtype.val) :=
  rfl

/-- The `TileSet` of those tiles from `t` containing a point from `s`. -/
def patch (t : TileSet ps ιₜ) (s : Set X) :
    TileSet ps (Subtype (fun i ↦ (s ∩ t i).Nonempty)) :=
  t.subtype _

@[simp] lemma coe_patch (t : TileSet ps ιₜ) (s : Set X) : ↑(t.patch s) = ↑t ∘ Subtype.val :=
  t.coe_subtype _

@[simp] lemma patch_apply (t : TileSet ps ιₜ) (s : Set X) (i) :
    t.patch s i = t i :=
  t.subtype_apply _ _

lemma injective_patch_of_injective {t : TileSet ps ιₜ} (s : Set X) (ht : Injective t) :
    Injective (t.patch s) :=
  injective_subtype_of_injective _ ht

lemma patch_reindex_subtypeEquiv (t : TileSet ps ιₜ) (s : Set X) {e : ιₜ' ≃ ιₜ} :
    (t.patch s).reindex (Equiv.subtypeEquiv e fun _ ↦ Iff.rfl) = (t.reindex e).patch s :=
  rfl

lemma patch_reindex_subtypeEquivRight (t : TileSet ps ιₜ) {s₁ s₂ : Set X}
    (h : ∀ i, (s₂ ∩ t i).Nonempty ↔ (s₁ ∩ t i).Nonempty) :
    (t.patch s₁).reindex (Equiv.subtypeEquivRight h) = t.patch s₂ :=
  t.reindex_subtypeEquivRight h

lemma coeSet_patch (t : TileSet ps ιₜ) (s : Set X) :
    t.patch s = t '' {i | (s ∩ t i).Nonempty} :=
  t.coeSet_subtype _

lemma coeSet_patch_subset (t : TileSet ps ιₜ) (s : Set X) :
    (t.patch s : Set (PlacedTile ps)) ⊆ t :=
  t.coeSet_subtype_subset _

lemma mem_of_mem_patch {t : TileSet ps ιₜ} {s : Set X} {pt : PlacedTile ps} (h : pt ∈ t.patch s) :
    pt ∈ t :=
  t.mem_of_mem_subtype h

lemma mem_patch_iff {t : TileSet ps ιₜ} {s : Set X} {pt : PlacedTile ps} :
    pt ∈ t.patch s ↔ (s ∩ pt).Nonempty ∧ pt ∈ t := by
  rw [patch, mem_subtype_iff, TileSet.mem_def, ←exists_and_left]
  refine exists_congr fun i ↦ ?_
  rw [and_congr_left_iff]
  rintro rfl
  rfl

/-- An equivalence between index subtypes for a patch from a `TileSet` and a corresponding patch
with the same group element applied to both the `TileSet` and the set of points. -/
def smulPatchEquiv (g : G) (t : TileSet ps ιₜ) (s : Set X) :
    {i // (g • s ∩ ((g • t) i)).Nonempty} ≃ {i // (s ∩ t i).Nonempty} :=
  Equiv.subtypeEquivRight (by simp)

lemma smul_patch (g : G) (t : TileSet ps ιₜ) (s : Set X) :
    (g • (t.patch s)).reindex (smulPatchEquiv g t s) = (g • t).patch (g • s) :=
  rfl

lemma Disjoint.patch {t : TileSet ps ιₜ} (hd : TileSet.Disjoint t) (s : Set X) :
    TileSet.Disjoint (t.patch s) :=
  TileSet.Disjoint.subtype hd _

lemma union_patch (t : TileSet ps ιₜ) (s : Set X) :
    ⋃ i, (t.patch s i : Set X) = ⋃ (i) (_ : (s ∩ t i).Nonempty), (t i : Set X) :=
  t.union_subtype _

lemma union_patch' (t : TileSet ps ιₜ) (s : Set X) :
    ⋃ pt ∈ t.patch s, (pt : Set X) = ⋃ (i) (_ : (s ∩ t i).Nonempty), (t i : Set X) :=
  t.union_subtype' _

/-- An equivalence between index subtypes for a patch of a patch and a corresponding patch taken
directly from the original `TileSet`. -/
def patchPatchEquiv (t : TileSet ps ιₜ) {s₁ s₂ : Set X} (h : s₂ ⊆ s₁) :
    {i // (s₂ ∩ t.patch s₁ i).Nonempty} ≃ {i // (s₂ ∩ t i).Nonempty} where
  toFun := fun i ↦ ⟨↑↑i, by exact i.property⟩
  invFun := fun i ↦ ⟨⟨↑i, i.property.mono <| by gcongr⟩, i.property⟩
  left_inv := by simp [LeftInverse]
  right_inv := by simp [Function.RightInverse, LeftInverse]

lemma patch_patch_reindex (t : TileSet ps ιₜ) {s₁ s₂ : Set X} (h : s₂ ⊆ s₁) :
    (t.patch s₂).reindex (t.patchPatchEquiv h) = (t.patch s₁).patch s₂ :=
  rfl

end TileSet

end Discrete
